# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    instruction.txt                                    :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: sverkart <sverkart@msk.21-school.ru>       +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2020/06/03 17:06:01 by sverkart          #+#    #+#              #
#    Updated: 2020/06/03 18:21:18 by sverkart         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

static int ft_create_new_line(char **fd_arr, char **line, char *nl_addr)
{
	char *temp;

	*nl_addr++ = '\0'; //перенос строки заменил 0 чтобы работать как со строкой, также тут сделан инкримент т/е смотрю конец ли файл или можно еще что-то считать
	*line = ft_strdup(*fd_arr); // записал в лайн строку до первого симола переноса строки
	if (*nl_addr == '\0') // 
	{
		free(*fd_arr); // если конец строки то все обнуляется и с 
		*fd_arr = NULL; // обнуляется статитк и прощание с файлом
		return (1); // 
	}
	temp = ft_strdup(nl_addr); // если в файле что-то осталось тогда это записывается в темп
	free(*fd_arr); // 
	*fd_arr = temp; // хранится остальной кусок который мог быть считан
	return (1); // строка заполнилась и из функции вышли
}

static int ft_process_output(char **fd_arr, char **line, int ret)
{//
	char *nl_addr;//
/*
Может быть такая ситуация когда в fd_arr по файлу дискриптору не найден символ переноса строки и файл полностью считан
тогда этот цикл не продолжается дальше и включается функция процесс_аут которая отвечает в том числе за вывод и тут 
обрабатывается вариант когда неудалось считать т/е ретурн -1. если вдруг нет символа переноса строки  и там конец файла
я создаю новую линию которая кончается енд офф лайн. и тогда этот кусок fd_arr который остался после того как весь файл
обработан я его записываю в line потому что это последняя строка и она терминирована 0 условным. да но по сути она 
записываю в line как файл кончился/ обнуля fd_arr и если вдруг там больше ничего нет никакой строки тогда я возвращаю пустую
строку/ а если что-то есть? тогда выйдет там где fd существует записывается в line. Туда записывается либо что-то либо ничего
fd limit - это дефайн кол-ва возможно открытых файл дискрипторов которые в хедоре существуют

*/
	if (ret < 0)//
	 	return (-1);//
	if (*fd && (nl_addr = ft_strchr(*fd_arr)))// для поиска певрого вхождения символа переноса строки
		return (ft_create_new_line(fd_arr, line, nl_addr));//
	if (*fd_arr)// 
	{
		*line = *fd_arr;//
		*fd_arr = NULL;//
		return (0);//
	}
	*line = ft_strdup("");//
	return (0);//
}

int get_next_line(int fd, char **line)
{
	static char	*fd_arr[FDLIMIT]; // это дефайн в хедере. он обозначает количество файлов которые можно открыть одновременно
	char		buff[BUFFER_SIZE + 1]; буффер сайз при копиляции передается. размер буфера в котором будет считываться файл
	int			ret; - сколько символов прочитано
	char		*nl_addr; - в нее будет записан адрес первого вхождения символа переноса строки 
	//Проверка на невалидность значаний.read (fd, buf, BUFFER_SIZE) > 0  - проверка что не подали нам директорию
	if ((fd < 0) || (line == 0) || (BUFFER_SIZE <=0 || (read(fd, buff, 0) < 0))
		return (-1);
	// Далее чтение буфера от размера из файла дискриптора/
	while ((ret = read(fd, buf, BUFFER_SIZE)) > 0) // ret - кол-во считываемых символов/ в данной строке пытаюсь считать файл 
	// пока он считывается
	{
		buf[ret] = '\0'; // в конец сразу 0 чтобы работать с буфером как со строкой
		fd_arr[fd] = ft_stroppend(fd_arr[fd], buf); // далее по адресу фд дискриптора строку которую считался буфер
		// и если есть друга строка то ее увеличиваю. Добавляется буфер к тому, что имеется. Далее ищу символ переноса строки 
		if ((nl_addr = ft_strchr(fd_arr[fd])))
			return (ft_create_new_line(&fd_arr[fd,line, nl_addr]));
	}
	return (ft_process_output(&fd_arr[fd], line, ret));  // на 
}

вспомогательные функции

ft_strlen;
ft_strdup;
ft_strchr;
ft_stroppend(char *s1, char *s2) // модифицированная join которввя еще чистит с1
{
	int len1;
	int len2;
	char *result;
	char *str;

	if (!s1 && !s2)
		return (NULL);
	if (!(s1) || !(s2))
		return (!(s1) ? ft_strdup(s2) : ft_strdup(s1));
	len1 = ft_strlen(s1); 
	len2 = ft_strlen(s2);
	if (!(str = (char*)malloc(sizeof(char) * (len1 + len2 +1))))
		return (NULL);
	result = str;
	whhile (*s1)
		*str++ = *s1++;
	free(s1 - len1);
	while (*s2)
		*str++ = *s2++;
	*str = '\0';
	return (result);



}